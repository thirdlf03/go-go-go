"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addIncludePathResolver = addIncludePathResolver;
exports.getTypeName = getTypeName;
exports.walkToFindTypePath = walkToFindTypePath;
const tslib_1 = require("tslib");
const lodash_has_1 = tslib_1.__importDefault(require("lodash.has"));
const cross_helpers_1 = require("@graphql-mesh/cross-helpers");
const scalars_js_1 = require("./scalars.js");
function addIncludePathResolver(root, includePaths) {
    const originalResolvePath = root.resolvePath;
    root.resolvePath = (origin, target) => {
        if (cross_helpers_1.path.isAbsolute(target)) {
            return target;
        }
        for (const directory of includePaths) {
            const fullPath = cross_helpers_1.path.join(directory, target);
            if (cross_helpers_1.fs.existsSync(fullPath)) {
                return fullPath;
            }
        }
        const path = originalResolvePath(origin, target);
        if (path === null) {
            console.warn(`${target} not found in any of the include paths ${includePaths}`);
        }
        return path;
    };
}
function getTypeName(schemaComposer, pathWithName, isInput) {
    if (pathWithName?.length) {
        const baseTypeName = pathWithName.filter(Boolean).join('__');
        if ((0, scalars_js_1.isGrpcScalar)(baseTypeName)) {
            return (0, scalars_js_1.getGraphQLScalarForGrpc)(baseTypeName);
        }
        if (schemaComposer.isEnumType(baseTypeName)) {
            return baseTypeName;
        }
        return isInput ? baseTypeName + '_Input' : baseTypeName;
    }
    return 'Void';
}
function walkToFindTypePath(rootJson, pathWithName, baseTypePath) {
    const currentWalkingPath = [...pathWithName];
    while (!(0, lodash_has_1.default)(rootJson.nested, currentWalkingPath.concat(baseTypePath).join('.nested.'))) {
        if (!currentWalkingPath.length) {
            break;
        }
        currentWalkingPath.pop();
    }
    return currentWalkingPath.concat(baseTypePath);
}
