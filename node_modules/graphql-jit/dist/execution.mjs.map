{"version":3,"sources":["../src/execution.ts"],"sourcesContent":["import { type TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport fastJson from \"fast-json-stringify\";\nimport { genFn } from \"./generate\";\nimport {\n  type ASTNode,\n  type DocumentNode,\n  type ExecutionResult,\n  type FragmentDefinitionNode,\n  type GraphQLAbstractType,\n  GraphQLEnumType,\n  GraphQLError,\n  type GraphQLFieldResolver,\n  type GraphQLIsTypeOfFn,\n  type GraphQLLeafType,\n  GraphQLList,\n  GraphQLObjectType,\n  type GraphQLOutputType,\n  type GraphQLResolveInfo,\n  type GraphQLScalarSerializer,\n  GraphQLScalarType,\n  GraphQLSchema,\n  type GraphQLType,\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n  isSpecifiedScalarType,\n  Kind,\n  locatedError,\n  TypeNameMetaFieldDef,\n  type FieldNode,\n  type OperationDefinitionNode,\n  type GraphQLTypeResolver\n} from \"graphql\";\nimport { type ExecutionContext as GraphQLContext } from \"graphql/execution/execute.js\";\nimport { pathToArray } from \"graphql/jsutils/Path.js\";\nimport {\n  addPath,\n  type Arguments,\n  collectFields,\n  collectSubfields,\n  computeLocations,\n  type FieldsAndNodes,\n  flattenPath,\n  getArgumentDefs,\n  type JitFieldNode,\n  joinSkipIncludePath,\n  type ObjectPath,\n  resolveFieldDef,\n  serializeObjectPathForSkipInclude\n} from \"./ast.js\";\nimport { GraphQLError as GraphqlJitError } from \"./error.js\";\nimport createInspect from \"./inspect.js\";\nimport { queryToJSONSchema } from \"./json.js\";\nimport { createNullTrimmer, type NullTrimmer } from \"./non-null.js\";\nimport {\n  createResolveInfoThunk,\n  type ResolveInfoEnricherInput\n} from \"./resolve-info.js\";\nimport { type Maybe } from \"./types.js\";\nimport {\n  type CoercedVariableValues,\n  compileVariableParsing,\n  failToParseVariables\n} from \"./variables.js\";\nimport { getGraphQLErrorOptions, getOperationRootType } from \"./compat.js\";\nimport memoize from \"lodash.memoize\";\n\nconst inspect = createInspect();\nconst joinOriginPaths = memoize(joinOriginPathsImpl);\n\nexport interface CompilerOptions {\n  customJSONSerializer: boolean;\n\n  // Disable builtin scalars and enum serialization\n  // which is responsible for coercion,\n  // only safe for use if the output is completely correct.\n  disableLeafSerialization: boolean;\n\n  // Disable capturing the stack trace of errors.\n  disablingCapturingStackErrors: boolean;\n\n  // Map of serializers to override\n  // the key should be the name passed to the Scalar or Enum type\n  customSerializers: { [key: string]: (v: any) => any };\n\n  resolverInfoEnricher?: (inp: ResolveInfoEnricherInput) => object;\n\n  /**\n   * This option is a temporary workaround to rollout and test the new skip/include behavior.\n   * It will be removed in the next version along with the old behavior.\n   *\n   * Set this to true if you face issues with skip/include in fragment spreads.\n   *\n   * default: false\n   *\n   * @see https://github.com/zalando-incubator/graphql-jit/pull/197\n   *\n   */\n  useExperimentalPathBasedSkipInclude: boolean;\n}\n\ninterface ExecutionContext {\n  promiseCounter: number;\n  data: any;\n  errors: GraphQLError[];\n  nullErrors: GraphQLError[];\n  resolve?: () => void;\n  inspect: typeof inspect;\n  variables: { [key: string]: any };\n  context: any;\n  rootValue: any;\n  safeMap: typeof safeMap;\n  GraphQLError: typeof GraphqlJitError;\n  resolvers: { [key: string]: GraphQLFieldResolver<any, any, any> };\n  trimmer: NullTrimmer;\n  serializers: {\n    [key: string]: (\n      c: ExecutionContext,\n      v: any,\n      onError: (c: ExecutionContext, msg: string) => void\n    ) => any;\n  };\n  typeResolvers: { [key: string]: GraphQLTypeResolver<any, any> };\n  isTypeOfs: { [key: string]: GraphQLIsTypeOfFn<any, any> };\n  resolveInfos: { [key: string]: any };\n}\n\ninterface DeferredField {\n  name: string;\n  responsePath: ObjectPath;\n  originPaths: string[];\n  originPathsFormatted: string;\n  destinationPaths: string[];\n  parentType: GraphQLObjectType;\n  fieldName: string;\n  jsFieldName: string;\n  fieldType: GraphQLOutputType;\n  fieldNodes: FieldNode[];\n  args: Arguments;\n}\n\n/**\n * The context used during compilation.\n *\n * It stores deferred nodes to be processed later as well as the function arguments to be bounded at top level\n */\nexport interface CompilationContext extends GraphQLContext {\n  resolvers: { [key: string]: GraphQLFieldResolver<any, any, any> };\n  serializers: {\n    [key: string]: (\n      c: ExecutionContext,\n      v: any,\n      onError: (c: ExecutionContext, msg: string) => void\n    ) => any;\n  };\n  hoistedFunctions: string[];\n  hoistedFunctionNames: Map<string, number>;\n  typeResolvers: { [key: string]: GraphQLTypeResolver<any, any> };\n  isTypeOfs: { [key: string]: GraphQLIsTypeOfFn<any, any> };\n  resolveInfos: { [key: string]: any };\n  deferred: DeferredField[];\n  options: CompilerOptions;\n  depth: number;\n}\n\n// prefix for the variable used ot cache validation results\nconst SAFETY_CHECK_PREFIX = \"__validNode\";\nconst GLOBAL_DATA_NAME = \"__context.data\";\nconst GLOBAL_ERRORS_NAME = \"__context.errors\";\nconst GLOBAL_NULL_ERRORS_NAME = \"__context.nullErrors\";\nconst GLOBAL_ROOT_NAME = \"__context.rootValue\";\nexport const GLOBAL_VARIABLES_NAME = \"__context.variables\";\nconst GLOBAL_CONTEXT_NAME = \"__context.context\";\nconst GLOBAL_EXECUTION_CONTEXT = \"__context\";\nconst GLOBAL_PROMISE_COUNTER = \"__context.promiseCounter\";\nconst GLOBAL_INSPECT_NAME = \"__context.inspect\";\nconst GLOBAL_SAFE_MAP_NAME = \"__context.safeMap\";\nconst GRAPHQL_ERROR = \"__context.GraphQLError\";\nconst GLOBAL_RESOLVE = \"__context.resolve\";\nconst GLOBAL_PARENT_NAME = \"__parent\";\nconst LOCAL_JS_FIELD_NAME_PREFIX = \"__field\";\n\nexport interface CompiledQuery<\n  TResult = { [key: string]: any },\n  TVariables = { [key: string]: any }\n> {\n  operationName?: string;\n  query: (\n    root: any,\n    context: any,\n    variables: Maybe<TVariables>\n  ) => Promise<ExecutionResult<TResult>> | ExecutionResult<TResult>;\n  subscribe?: (\n    root: any,\n    context: any,\n    variables: Maybe<TVariables>\n  ) => Promise<\n    AsyncIterableIterator<ExecutionResult<TResult>> | ExecutionResult<TResult>\n  >;\n  stringify: (v: any) => string;\n}\n\ninterface InternalCompiledQuery extends CompiledQuery {\n  __DO_NOT_USE_THIS_OR_YOU_WILL_BE_FIRED_compilation?: string;\n}\n\n/**\n * It compiles a GraphQL query to an executable function\n * @param {GraphQLSchema} schema GraphQL schema\n * @param {DocumentNode} document Query being submitted\n * @param {string} operationName name of the operation\n * @param partialOptions compilation options to tune the compiler features\n * @returns {CompiledQuery} the cacheable result\n */\nexport function compileQuery<\n  TResult = { [key: string]: any },\n  TVariables = { [key: string]: any }\n>(\n  schema: GraphQLSchema,\n  document: TypedDocumentNode<TResult, TVariables>,\n  operationName?: string,\n  partialOptions?: Partial<CompilerOptions>\n): CompiledQuery<TResult, TVariables> | ExecutionResult<TResult> {\n  if (!schema) {\n    throw new Error(`Expected ${schema} to be a GraphQL schema.`);\n  }\n  if (!document) {\n    throw new Error(\"Must provide document.\");\n  }\n\n  if (\n    partialOptions &&\n    partialOptions.resolverInfoEnricher &&\n    typeof partialOptions.resolverInfoEnricher !== \"function\"\n  ) {\n    throw new Error(\"resolverInfoEnricher must be a function\");\n  }\n  try {\n    const options = {\n      disablingCapturingStackErrors: false,\n      customJSONSerializer: false,\n      disableLeafSerialization: false,\n      customSerializers: {},\n      useExperimentalPathBasedSkipInclude: false,\n      ...partialOptions\n    };\n\n    // If a valid context cannot be created due to incorrect arguments,\n    // a \"Response\" with only errors is returned.\n    const context = buildCompilationContext(\n      schema,\n      document,\n      options,\n      operationName\n    );\n\n    let stringify: (v: any) => string;\n    if (options.customJSONSerializer) {\n      const jsonSchema = queryToJSONSchema(context);\n      stringify = fastJson(jsonSchema);\n    } else {\n      stringify = JSON.stringify;\n    }\n    const getVariables = compileVariableParsing(\n      schema,\n      context.operation.variableDefinitions || []\n    );\n\n    const type = getOperationRootType(context.schema, context.operation);\n    const fieldMap = collectFields(\n      context,\n      type,\n      context.operation.selectionSet,\n      Object.create(null),\n      Object.create(null)\n    );\n\n    const functionBody = compileOperation(context, type, fieldMap);\n\n    const compiledQuery: InternalCompiledQuery = {\n      query: createBoundQuery(\n        context,\n        document,\n        // eslint-disable-next-line no-new-func\n        new Function(\"return \" + functionBody)(),\n        getVariables,\n        context.operation.name != null\n          ? context.operation.name.value\n          : undefined\n      ),\n      stringify\n    };\n\n    if (context.operation.operation === \"subscription\") {\n      compiledQuery.subscribe = createBoundSubscribe(\n        context,\n        document,\n        compileSubscriptionOperation(\n          context,\n          type,\n          fieldMap,\n          compiledQuery.query\n        ),\n        getVariables,\n        context.operation.name != null\n          ? context.operation.name.value\n          : undefined\n      );\n    }\n\n    if ((options as any).debug) {\n      // result of the compilation useful for debugging issues\n      // and visualization tools like try-jit.\n      compiledQuery.__DO_NOT_USE_THIS_OR_YOU_WILL_BE_FIRED_compilation =\n        functionBody;\n    }\n    return compiledQuery as CompiledQuery<TResult, TVariables>;\n  } catch (err: any) {\n    return {\n      errors: normalizeErrors(err)\n    };\n  }\n}\n\nexport function isCompiledQuery<\n  C extends CompiledQuery,\n  E extends ExecutionResult\n>(query: C | E): query is C {\n  return \"query\" in query && typeof query.query === \"function\";\n}\n\n// Exported only for an error test\nexport function createBoundQuery(\n  compilationContext: CompilationContext,\n  document: DocumentNode,\n  func: (context: ExecutionContext) => Promise<any> | undefined,\n  getVariableValues: (inputs: { [key: string]: any }) => CoercedVariableValues,\n  operationName?: string\n) {\n  const { resolvers, typeResolvers, isTypeOfs, serializers, resolveInfos } =\n    compilationContext;\n  const trimmer = createNullTrimmer(compilationContext);\n  const fnName = operationName || \"query\";\n\n  /**\n   * In-order to assign a debuggable name to the bound query function,\n   * we create an intermediate object with a method named as the\n   * intended function name. This is because Function.prototype.name\n   * is not writeable.\n   *\n   * http://www.ecma-international.org/ecma-262/6.0/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation\n   *\n   * section: 14.3.9.3 - calls SetFunctionName\n   */\n  const ret = {\n    [fnName](\n      rootValue: any,\n      context: any,\n      variables: Maybe<{ [key: string]: any }>\n    ): Promise<ExecutionResult> | ExecutionResult {\n      // this can be shared across in a batch request\n      const parsedVariables = getVariableValues(variables || {});\n\n      // Return early errors if variable coercing failed.\n      if (failToParseVariables(parsedVariables)) {\n        return { errors: parsedVariables.errors };\n      }\n      const executionContext: ExecutionContext = {\n        rootValue,\n        context,\n        variables: parsedVariables.coerced,\n        safeMap,\n        inspect,\n        GraphQLError: GraphqlJitError,\n        resolvers,\n        typeResolvers,\n        isTypeOfs,\n        serializers,\n        resolveInfos,\n        trimmer,\n        promiseCounter: 0,\n        data: {},\n        nullErrors: [],\n        errors: []\n      };\n      // eslint-disable-next-line no-useless-call\n      const result = func.call(null, executionContext);\n      if (isPromise(result)) {\n        return result.then(postProcessResult);\n      }\n      return postProcessResult(executionContext);\n    }\n  };\n\n  return ret[fnName];\n}\n\nfunction postProcessResult({\n  data,\n  nullErrors,\n  errors,\n  trimmer\n}: ExecutionContext) {\n  if (nullErrors.length > 0) {\n    const trimmed = trimmer(data, nullErrors);\n    return {\n      data: trimmed.data,\n      errors: errors.concat(trimmed.errors)\n    };\n  } else if (errors.length > 0) {\n    return {\n      data,\n      errors\n    };\n  }\n  return { data };\n}\n\n/**\n * Create the main function body.\n *\n * Implements the \"Evaluating operations\" section of the spec.\n *\n * It defers all top level field for consistency and protection for null root values,\n * all the fields are deferred regardless of presence of resolver or not.\n *\n * @param {CompilationContext} context compilation context with the execution context\n * @returns {string} a function body to be instantiated together with the header, footer\n */\nfunction compileOperation(\n  context: CompilationContext,\n  type: GraphQLObjectType,\n  fieldMap: FieldsAndNodes\n) {\n  const serialExecution = context.operation.operation === \"mutation\";\n  const topLevel = compileObjectType(\n    context,\n    type,\n    [],\n    [GLOBAL_ROOT_NAME],\n    [GLOBAL_DATA_NAME],\n    undefined,\n    GLOBAL_ERRORS_NAME,\n    fieldMap,\n    true\n  );\n  let body = `function query (${GLOBAL_EXECUTION_CONTEXT}) {\n  \"use strict\";\n`;\n  if (serialExecution) {\n    body += `${GLOBAL_EXECUTION_CONTEXT}.queue = [];`;\n  }\n  body += generateUniqueDeclarations(context, true);\n  body += `${GLOBAL_DATA_NAME} = ${topLevel}\\n`;\n  if (serialExecution) {\n    body += compileDeferredFieldsSerially(context);\n    body += `\n    ${GLOBAL_EXECUTION_CONTEXT}.finalResolve = () => {};\n    ${GLOBAL_RESOLVE} = (context) => {\n      if (context.jobCounter >= context.queue.length) {\n        // All mutations have finished\n        context.finalResolve(context);\n        return;\n      }\n      context.queue[context.jobCounter++](context);\n    };\n    // There might not be a job to run due to invalid queries\n    if (${GLOBAL_EXECUTION_CONTEXT}.queue.length > 0) {\n      ${GLOBAL_EXECUTION_CONTEXT}.jobCounter = 1; // since the first one will be run manually\n      ${GLOBAL_EXECUTION_CONTEXT}.queue[0](${GLOBAL_EXECUTION_CONTEXT});\n    }\n    // Promises have been scheduled so a new promise is returned\n    // that will be resolved once every promise is done\n    if (${GLOBAL_PROMISE_COUNTER} > 0) {\n      return new Promise(resolve => ${GLOBAL_EXECUTION_CONTEXT}.finalResolve = resolve);\n    }\n  `;\n  } else {\n    body += compileDeferredFields(context);\n    body += `\n    // Promises have been scheduled so a new promise is returned\n    // that will be resolved once every promise is done\n    if (${GLOBAL_PROMISE_COUNTER} > 0) {\n      return new Promise(resolve => ${GLOBAL_RESOLVE} = resolve);\n    }`;\n  }\n  body += `\n  // sync execution, the results are ready\n  return undefined;\n  }`;\n  body += context.hoistedFunctions.join(\"\\n\");\n  return body;\n}\n\n/**\n * Processes the deferred node list in the compilation context.\n *\n * Each deferred node get a copy of the compilation context with\n * a new empty list for deferred nodes to properly scope the nodes.\n * @param {CompilationContext} context compilation context\n * @returns {string} compiled transformations all of deferred nodes\n */\nfunction compileDeferredFields(context: CompilationContext): string {\n  let body = \"\";\n  context.deferred.forEach((deferredField, index) => {\n    body += `\n      if (${SAFETY_CHECK_PREFIX}${index}) {\n        ${compileDeferredField(context, deferredField)}\n      }`;\n  });\n  return body;\n}\n\nfunction compileDeferredField(\n  context: CompilationContext,\n  deferredField: DeferredField,\n  appendix?: string\n): string {\n  const {\n    name,\n    originPathsFormatted,\n    destinationPaths,\n    fieldNodes,\n    fieldType,\n    fieldName,\n    jsFieldName,\n    responsePath,\n    parentType,\n    args\n  } = deferredField;\n\n  const subContext = createSubCompilationContext(context);\n  const nodeBody = compileType(\n    subContext,\n    parentType,\n    fieldType,\n    fieldNodes,\n    [jsFieldName],\n    [`${GLOBAL_PARENT_NAME}.${name}`],\n    responsePath\n  );\n  const parentIndexes = getParentArgIndexes(context);\n  const resolverName = getResolverName(parentType.name, fieldName);\n  const resolverHandler = getHoistedFunctionName(\n    context,\n    `${name}${resolverName}Handler`\n  );\n  const topLevelArgs = getArgumentsName(resolverName);\n  const validArgs = getValidArgumentsVarName(resolverName);\n  const executionError = createErrorObject(\n    context,\n    fieldNodes,\n    responsePath,\n    \"err.message != null ? err.message : err\",\n    \"err\"\n  );\n  const executionInfo = getExecutionInfo(\n    subContext,\n    parentType,\n    fieldType,\n    fieldName,\n    fieldNodes,\n    responsePath\n  );\n  const emptyError = createErrorObject(context, fieldNodes, responsePath, '\"\"');\n  const resolverParentPath = originPathsFormatted;\n  const resolverCall = `${GLOBAL_EXECUTION_CONTEXT}.resolvers.${resolverName}(\n          ${resolverParentPath},${topLevelArgs},${GLOBAL_CONTEXT_NAME}, ${executionInfo})`;\n  const resultParentPath = destinationPaths.join(\".\");\n  const compiledArgs = compileArguments(\n    subContext,\n    args,\n    topLevelArgs,\n    validArgs,\n    fieldType,\n    responsePath\n  );\n  const body = `\n    ${compiledArgs}\n    if (${validArgs} === true) {\n      var __value = null;\n      try {\n        __value = ${resolverCall};\n      } catch (err) {\n        ${getErrorDestination(fieldType)}.push(${executionError});\n      }\n      if (${isPromiseInliner(\"__value\")}) {\n      ${promiseStarted()}\n       __value.then(result => {\n        ${resolverHandler}(${GLOBAL_EXECUTION_CONTEXT}, ${resultParentPath}, result, ${parentIndexes});\n        ${promiseDone()}\n       }, err => {\n        if (err) {\n          ${getErrorDestination(fieldType)}.push(${executionError});\n        } else {\n          ${getErrorDestination(fieldType)}.push(${emptyError});\n        }\n        ${promiseDone()}\n       });\n      } else {\n        ${resolverHandler}(${GLOBAL_EXECUTION_CONTEXT}, ${resultParentPath}, __value, ${parentIndexes});\n      }\n    }`;\n  context.hoistedFunctions.push(`\n    function ${resolverHandler}(${GLOBAL_EXECUTION_CONTEXT}, ${GLOBAL_PARENT_NAME}, ${jsFieldName}, ${parentIndexes}) {\n      ${generateUniqueDeclarations(subContext)}\n      ${GLOBAL_PARENT_NAME}.${name} = ${nodeBody};\n      ${compileDeferredFields(subContext)}\n      ${appendix || \"\"}\n    }\n  `);\n  return body;\n}\n\nfunction compileDeferredFieldsSerially(context: CompilationContext): string {\n  let body = \"\";\n  context.deferred.forEach((deferredField, index) => {\n    const { name, fieldName, parentType } = deferredField;\n    const resolverName = getResolverName(parentType.name, fieldName);\n    const mutationHandler = getHoistedFunctionName(\n      context,\n      `${name}${resolverName}Mutation`\n    );\n    body += `\n      if (${SAFETY_CHECK_PREFIX}${index}) {\n        ${GLOBAL_EXECUTION_CONTEXT}.queue.push(${mutationHandler});\n      }\n    `;\n    const appendix = `\n    if (${GLOBAL_PROMISE_COUNTER} === 0) {\n      ${GLOBAL_RESOLVE}(${GLOBAL_EXECUTION_CONTEXT});\n    }\n    `;\n    context.hoistedFunctions.push(`\n      function ${mutationHandler}(${GLOBAL_EXECUTION_CONTEXT}) {\n        ${compileDeferredField(context, deferredField, appendix)}\n      }\n      `);\n  });\n  return body;\n}\n\n/**\n * Processes a generic node.\n *\n * The type is analysed and later reprocessed in dedicated functions.\n * @param {CompilationContext} context compilation context to hold deferred nodes\n * @param parentType\n * @param {GraphQLType} type type of current parent node\n * @param {FieldNode[]} fieldNodes array of the field nodes\n * @param originPaths originPaths path in the parent object from where to fetch results\n * @param destinationPaths path in the where to write the result\n * @param previousPath response path until this node\n * @returns {string} body of the resolvable fieldNodes\n */\nfunction compileType(\n  context: CompilationContext,\n  parentType: GraphQLObjectType,\n  type: GraphQLType,\n  fieldNodes: FieldNode[],\n  originPaths: string[],\n  destinationPaths: string[],\n  previousPath: ObjectPath\n): string {\n  const sourcePath = joinOriginPaths(originPaths);\n  let body = `${sourcePath} == null ? `;\n  let errorDestination;\n  if (isNonNullType(type)) {\n    type = type.ofType;\n    const nullErrorStr = `\"Cannot return null for non-nullable field ${\n      parentType.name\n    }.${getFieldNodesName(fieldNodes)}.\"`;\n    body += `(${GLOBAL_NULL_ERRORS_NAME}.push(${createErrorObject(\n      context,\n      fieldNodes,\n      previousPath,\n      nullErrorStr\n    )}), null) :`;\n    errorDestination = GLOBAL_NULL_ERRORS_NAME;\n  } else {\n    body += \"null : \";\n    errorDestination = GLOBAL_ERRORS_NAME;\n  }\n  body += \"(\";\n  // value can be an error obj\n  const errorPath = `${sourcePath}.message != null ? ${sourcePath}.message : ${sourcePath}`;\n  body += `${sourcePath} instanceof Error ? (${errorDestination}.push(${createErrorObject(\n    context,\n    fieldNodes,\n    previousPath,\n    errorPath,\n    sourcePath\n  )}), null) : `;\n\n  if (isLeafType(type)) {\n    body += compileLeafType(\n      context,\n      type,\n      originPaths,\n      fieldNodes,\n      previousPath,\n      errorDestination\n    );\n  } else if (isObjectType(type)) {\n    const fieldMap = collectSubfields(context, type, fieldNodes, previousPath);\n    body += compileObjectType(\n      context,\n      type,\n      fieldNodes,\n      originPaths,\n      destinationPaths,\n      previousPath,\n      errorDestination,\n      fieldMap,\n      false\n    );\n  } else if (isAbstractType(type)) {\n    body += compileAbstractType(\n      context,\n      parentType,\n      type,\n      fieldNodes,\n      originPaths,\n      previousPath,\n      errorDestination\n    );\n  } else if (isListType(type)) {\n    body += compileListType(\n      context,\n      parentType,\n      type,\n      fieldNodes,\n      originPaths,\n      previousPath,\n      errorDestination\n    );\n  } else {\n    /* istanbul ignore next */\n    throw new Error(`unsupported type: ${type.toString()}`);\n  }\n  body += \")\";\n  return body;\n}\n\nfunction compileLeafType(\n  context: CompilationContext,\n  type: GraphQLLeafType,\n  originPaths: string[],\n  fieldNodes: FieldNode[],\n  previousPath: ObjectPath,\n  errorDestination: string\n) {\n  let body = \"\";\n  if (\n    context.options.disableLeafSerialization &&\n    (type instanceof GraphQLEnumType || isSpecifiedScalarType(type))\n  ) {\n    body += `${joinOriginPaths(originPaths)}`;\n  } else {\n    const serializerName = getSerializerName(type.name);\n    context.serializers[serializerName] = getSerializer(\n      type,\n      context.options.customSerializers[type.name]\n    );\n    const parentIndexes = getParentArgIndexes(context);\n    const serializerErrorHandler = getHoistedFunctionName(\n      context,\n      `${type.name}${originPaths.join(\"\")}SerializerErrorHandler`\n    );\n    context.hoistedFunctions.push(`\n    function ${serializerErrorHandler}(${GLOBAL_EXECUTION_CONTEXT}, message, ${parentIndexes}) {\n    ${errorDestination}.push(${createErrorObject(\n      context,\n      fieldNodes,\n      previousPath,\n      \"message\"\n    )});}\n    `);\n    body += `${GLOBAL_EXECUTION_CONTEXT}.serializers.${serializerName}(${GLOBAL_EXECUTION_CONTEXT}, ${joinOriginPaths(\n      originPaths\n    )}, ${serializerErrorHandler}, ${parentIndexes})`;\n  }\n  return body;\n}\n\n/**\n * Compile a node of object type.\n * @param {CompilationContext} context\n * @param {GraphQLObjectType} type type of the node\n * @param fieldNodes fieldNodes array with the nodes references\n * @param originPaths originPaths path in the parent object from where to fetch results\n * @param destinationPaths path in the where to write the result\n * @param responsePath response path until this node\n * @param errorDestination Path for error array\n * @param fieldMap map of fields to fieldNodes array with the nodes references\n * @param alwaysDefer used to force the field to be resolved with a resolver ala graphql-js\n * @returns {string}\n */\nfunction compileObjectType(\n  context: CompilationContext,\n  type: GraphQLObjectType,\n  fieldNodes: JitFieldNode[],\n  originPaths: string[],\n  destinationPaths: string[],\n  responsePath: ObjectPath | undefined,\n  errorDestination: string,\n  fieldMap: FieldsAndNodes,\n  alwaysDefer: boolean\n): string {\n  const body = genFn();\n\n  // Begin object compilation paren\n  body(\"(\");\n  if (typeof type.isTypeOf === \"function\" && !alwaysDefer) {\n    context.isTypeOfs[type.name + \"IsTypeOf\"] = type.isTypeOf;\n    body(\n      `!${GLOBAL_EXECUTION_CONTEXT}.isTypeOfs[\"${\n        type.name\n      }IsTypeOf\"](${joinOriginPaths(\n        originPaths\n      )}) ? (${errorDestination}.push(${createErrorObject(\n        context,\n        fieldNodes,\n        responsePath as any,\n        `\\`Expected value of type \"${\n          type.name\n        }\" but got: $\\{${GLOBAL_INSPECT_NAME}(${joinOriginPaths(\n          originPaths\n        )})}.\\``\n      )}), null) :`\n    );\n  }\n\n  // object start\n  body(\"{\");\n\n  for (const name of Object.keys(fieldMap)) {\n    const fieldNodes = fieldMap[name];\n    const field = resolveFieldDef(context, type, fieldNodes);\n    if (!field) {\n      // Field is invalid, should have been caught in validation\n      // but the error is swallowed for compatibility reasons.\n      continue;\n    }\n\n    // Key of the object\n    // `name` is the field name or an alias supplied by the user\n    body(`\"${name}\": `);\n\n    /**\n     * Value of the object\n     *\n     * The combined condition for whether a field should be included\n     * in the object.\n     *\n     * Here, the logical operation is `||` because every fieldNode\n     * is at the same level in the tree, if at least \"one of\" the nodes\n     * is included, then the field is included.\n     *\n     * For example,\n     *\n     * ```graphql\n     * {\n     *   foo @skip(if: $c1)\n     *   ... { foo @skip(if: $c2) }\n     * }\n     * ```\n     *\n     * The logic for `foo` becomes -\n     *\n     * `compilationFor($c1) || compilationFor($c2)`\n     */\n    const serializedResponsePath = joinSkipIncludePath(\n      serializeObjectPathForSkipInclude(responsePath),\n      name\n    );\n\n    const fieldConditionsList = (\n      context.options.useExperimentalPathBasedSkipInclude\n        ? fieldNodes.map(\n            (it) => it.__internalShouldIncludePath?.[serializedResponsePath]\n          )\n        : fieldNodes.map((it) => it.__internalShouldInclude)\n    ).filter(isNotNull);\n\n    let fieldCondition = fieldConditionsList\n      .map((it) => {\n        if (it.length > 0) {\n          return `(${it.join(\" && \")})`;\n        }\n        // default: if there are no conditions, it means that the field\n        // is always included in the path\n        return \"true\";\n      })\n      .filter(isNotNull)\n      .join(\" || \");\n\n    // if it's an empty string, it means that the field is always included\n    if (!fieldCondition) {\n      // if there are no conditions, it means that the field\n      // is always included in the path\n      fieldCondition = \"true\";\n    }\n\n    body(`\n      (\n        ${fieldCondition}\n      )\n    `);\n\n    // Inline __typename\n    // No need to call a resolver for typename\n    if (field === TypeNameMetaFieldDef) {\n      // type.name if field is included else undefined - to remove from object\n      // during serialization\n      body(`? \"${type.name}\" : undefined,`);\n      continue;\n    }\n\n    let resolver = field.resolve;\n    if (!resolver && alwaysDefer) {\n      const fieldName = field.name;\n      resolver = (parent) => parent && parent[fieldName];\n    }\n    if (resolver) {\n      context.deferred.push({\n        name,\n        responsePath: addPath(responsePath, name),\n        originPaths,\n        originPathsFormatted: joinOriginPaths(originPaths),\n        destinationPaths,\n        parentType: type,\n        fieldName: field.name,\n        jsFieldName: getJsFieldName(field.name),\n        fieldType: field.type,\n        fieldNodes,\n        args: getArgumentDefs(field, fieldNodes[0])\n      });\n      context.resolvers[getResolverName(type.name, field.name)] = resolver;\n      body(\n        `\n          ? (\n              ${SAFETY_CHECK_PREFIX}${context.deferred.length - 1} = true,\n              null\n            )\n          : (\n              ${SAFETY_CHECK_PREFIX}${context.deferred.length - 1} = false,\n              undefined\n            )\n        `\n      );\n    } else {\n      // if included\n      body(\"?\");\n      body(\n        compileType(\n          context,\n          type,\n          field.type,\n          fieldNodes,\n          originPaths.concat(field.name),\n          destinationPaths.concat(name),\n          addPath(responsePath, name)\n        )\n      );\n      // if not included\n      body(\": undefined\");\n    }\n    // End object property\n    body(\",\");\n  }\n\n  // End object\n  body(\"}\");\n  // End object compilation paren\n  body(\")\");\n\n  return body.toString();\n}\n\nfunction compileAbstractType(\n  context: CompilationContext,\n  parentType: GraphQLObjectType,\n  type: GraphQLAbstractType,\n  fieldNodes: FieldNode[],\n  originPaths: string[],\n  previousPath: ObjectPath,\n  errorDestination: string\n): string {\n  let resolveType: GraphQLTypeResolver<any, any>;\n  if (type.resolveType) {\n    resolveType = type.resolveType;\n  } else {\n    resolveType = (value: any, context: any, info: GraphQLResolveInfo) =>\n      defaultResolveTypeFn(value, context, info, type);\n  }\n  const typeResolverName = getTypeResolverName(type.name);\n  context.typeResolvers[typeResolverName] = resolveType;\n  const collectedTypes = context.schema\n    .getPossibleTypes(type)\n    .map((objectType) => {\n      const subContext = createSubCompilationContext(context);\n      const object = compileType(\n        subContext,\n        parentType,\n        objectType,\n        fieldNodes,\n        originPaths,\n        [\"__concrete\"],\n        addPath(previousPath, objectType.name, \"meta\")\n      );\n      return `case \"${objectType.name}\": {\n                  ${generateUniqueDeclarations(subContext)}\n                  const __concrete = ${object};\n                  ${compileDeferredFields(subContext)}\n                  return __concrete;\n              }`;\n    })\n    .join(\"\\n\");\n  const finalTypeName = \"finalType\";\n  const nullTypeError = `\"Runtime Object type is not a possible type for \\\\\"${type.name}\\\\\".\"`;\n\n  const notPossibleTypeError =\n    // eslint-disable-next-line no-template-curly-in-string\n    '`Runtime Object type \"${nodeType}\" is not a possible type for \"' +\n    type.name +\n    '\".`';\n  const noTypeError = `${finalTypeName} ? ${notPossibleTypeError} : \"Abstract type ${\n    type.name\n  } must resolve to an Object type at runtime for field ${\n    parentType.name\n  }.${getFieldNodesName(fieldNodes)}. Either the ${\n    type.name\n  } type should provide a \\\\\"resolveType\\\\\" function or each possible types should provide an \\\\\"isTypeOf\\\\\" function.\"`;\n\n  return `((nodeType, err) =>\n  {\n    if (err != null) {\n      ${errorDestination}.push(${createErrorObject(\n        context,\n        fieldNodes,\n        previousPath,\n        \"err.message != null ? err.message : err\",\n        \"err\"\n      )});\n      return null;\n    }\n    if (nodeType == null) {\n      ${errorDestination}.push(${createErrorObject(\n        context,\n        fieldNodes,\n        previousPath,\n        nullTypeError\n      )})\n      return null;\n    }\n    const ${finalTypeName} = typeof nodeType === \"string\" ? nodeType : nodeType.name;\n    switch(${finalTypeName}) {\n      ${collectedTypes}\n      default:\n      ${errorDestination}.push(${createErrorObject(\n        context,\n        fieldNodes,\n        previousPath,\n        noTypeError\n      )})\n      return null;\n    }\n  })(\n    ${GLOBAL_EXECUTION_CONTEXT}.typeResolvers.${typeResolverName}(${joinOriginPaths(\n      originPaths\n    )},\n    ${GLOBAL_CONTEXT_NAME},\n    ${getExecutionInfo(\n      context,\n      parentType,\n      type,\n      type.name,\n      fieldNodes,\n      previousPath\n    )}))`;\n}\n\n/**\n * Compile a list transformation.\n *\n * @param {CompilationContext} context\n * @param {GraphQLObjectType} parentType type of the parent of object which contained this type\n * @param {GraphQLList<GraphQLType>} type list type being compiled\n * @param {FieldNode[]} fieldNodes\n * @param originalObjectPaths\n * @param {ObjectPath} responsePath\n * @param errorDestination\n * @returns {string} compiled list transformation\n */\nfunction compileListType(\n  context: CompilationContext,\n  parentType: GraphQLObjectType,\n  type: GraphQLList<GraphQLType>,\n  fieldNodes: FieldNode[],\n  originalObjectPaths: string[],\n  responsePath: ObjectPath,\n  errorDestination: string\n) {\n  const name = originalObjectPaths.join(\".\");\n  const listContext = createSubCompilationContext(context);\n  // context depth will be mutated, so we cache the current value.\n  const newDepth = ++listContext.depth;\n  const fieldType = type.ofType;\n  const dataBody = compileType(\n    listContext,\n    parentType,\n    fieldType,\n    fieldNodes,\n    [\"__currentItem\"],\n    [`${GLOBAL_PARENT_NAME}[idx${newDepth}]`],\n    addPath(responsePath, \"idx\" + newDepth, \"variable\")\n  );\n\n  const errorMessage = `\"Expected Iterable, but did not find one for field ${\n    parentType.name\n  }.${getFieldNodesName(fieldNodes)}.\"`;\n  const errorCase = `(${errorDestination}.push(${createErrorObject(\n    context,\n    fieldNodes,\n    responsePath,\n    errorMessage\n  )}), null)`;\n  const executionError = createErrorObject(\n    context,\n    fieldNodes,\n    addPath(responsePath, \"idx\" + newDepth, \"variable\"),\n    \"err.message != null ? err.message : err\",\n    \"err\"\n  );\n  const emptyError = createErrorObject(context, fieldNodes, responsePath, '\"\"');\n  const uniqueDeclarations = generateUniqueDeclarations(listContext);\n  const deferredFields = compileDeferredFields(listContext);\n  const itemHandler = getHoistedFunctionName(\n    context,\n    `${parentType.name}${originalObjectPaths.join(\"\")}MapItemHandler`\n  );\n  const childIndexes = getParentArgIndexes(listContext);\n  listContext.hoistedFunctions.push(`\n  function ${itemHandler}(${GLOBAL_EXECUTION_CONTEXT}, ${GLOBAL_PARENT_NAME}, __currentItem, ${childIndexes}) {\n    ${uniqueDeclarations}\n    ${GLOBAL_PARENT_NAME}[idx${newDepth}] = ${dataBody};\n    ${deferredFields}\n  }\n  `);\n  const safeMapHandler = getHoistedFunctionName(\n    context,\n    `${parentType.name}${originalObjectPaths.join(\"\")}MapHandler`\n  );\n  const parentIndexes = getParentArgIndexes(context);\n  listContext.hoistedFunctions.push(`\n  function ${safeMapHandler}(${GLOBAL_EXECUTION_CONTEXT}, __currentItem, idx${newDepth}, resultArray, ${parentIndexes}) {\n    if (${isPromiseInliner(\"__currentItem\")}) {\n      ${promiseStarted()}\n      __currentItem.then(result => {\n        ${itemHandler}(${GLOBAL_EXECUTION_CONTEXT}, resultArray, result, ${childIndexes});\n        ${promiseDone()}\n      }, err => {\n        resultArray.push(null);\n        if (err) {\n          ${getErrorDestination(fieldType)}.push(${executionError});\n        } else {\n          ${getErrorDestination(fieldType)}.push(${emptyError});\n        }\n        ${promiseDone()}\n      });\n    } else {\n       ${itemHandler}(${GLOBAL_EXECUTION_CONTEXT}, resultArray, __currentItem, ${childIndexes});\n    }\n  }\n  `);\n  return `(typeof ${name} === \"string\" || typeof ${name}[Symbol.iterator] !== \"function\") ?  ${errorCase} :\n  ${GLOBAL_SAFE_MAP_NAME}(${GLOBAL_EXECUTION_CONTEXT}, ${name}, ${safeMapHandler}, ${parentIndexes})`;\n}\n\n/**\n * Implements a generic map operation for any iterable.\n *\n * If the iterable is not valid, null is returned.\n * @param context\n * @param {Iterable<any> | string} iterable possible iterable\n * @param {(a: any) => any} cb callback that receives the item being iterated\n * @param idx\n * @returns {any[]} a new array with the result of the callback\n */\nfunction safeMap(\n  context: ExecutionContext,\n  iterable: Iterable<any> | string,\n  cb: (\n    context: ExecutionContext,\n    a: any,\n    index: number,\n    resultArray: any[],\n    ...idx: number[]\n  ) => any,\n  ...idx: number[]\n): any[] {\n  let index = 0;\n  const result: any[] = [];\n  for (const a of iterable) {\n    cb(context, a, index, result, ...idx);\n    ++index;\n  }\n  return result;\n}\n\nconst MAGIC_MINUS_INFINITY =\n  \"__MAGIC_MINUS_INFINITY__71d4310a_d4a3_4a05_b1fe_e60779d24998\";\nconst MAGIC_PLUS_INFINITY =\n  \"__MAGIC_PLUS_INFINITY__bb201c39_3333_4695_b4ad_7f1722e7aa7a\";\nconst MAGIC_NAN = \"__MAGIC_NAN__57f286b9_4c20_487f_b409_79804ddcb4f8\";\nconst MAGIC_DATE = \"__MAGIC_DATE__33a9e76d_02e0_4128_8e92_3530ad3da74d\";\n\nfunction specialValueReplacer(this: any, key: any, value: any) {\n  if (Number.isNaN(value)) {\n    return MAGIC_NAN;\n  }\n\n  if (value === Infinity) {\n    return MAGIC_PLUS_INFINITY;\n  }\n\n  if (value === -Infinity) {\n    return MAGIC_MINUS_INFINITY;\n  }\n\n  if (this[key] instanceof Date) {\n    return MAGIC_DATE + this[key].getTime();\n  }\n\n  return value;\n}\n\nfunction objectStringify(val: any): string {\n  return JSON.stringify(val, specialValueReplacer)\n    .replace(new RegExp(`\"${MAGIC_NAN}\"`, \"g\"), \"NaN\")\n    .replace(new RegExp(`\"${MAGIC_PLUS_INFINITY}\"`, \"g\"), \"Infinity\")\n    .replace(new RegExp(`\"${MAGIC_MINUS_INFINITY}\"`, \"g\"), \"-Infinity\")\n    .replace(new RegExp(`\"${MAGIC_DATE}([^\"]+)\"`, \"g\"), \"new Date($1)\");\n}\n\n/**\n * Calculates a GraphQLResolveInfo object for the resolver calls.\n *\n * if the resolver does not use, it returns null.\n * @param {CompilationContext} context compilation context to submit the resolveInfoResolver\n * @param parentType\n * @param fieldType\n * @param fieldName\n * @param fieldNodes\n * @param responsePath\n * @returns {string} a call to the resolve info creator or \"{}\" if unused\n */\nfunction getExecutionInfo(\n  context: CompilationContext,\n  parentType: GraphQLObjectType,\n  fieldType: GraphQLOutputType,\n  fieldName: string,\n  fieldNodes: FieldNode[],\n  responsePath: ObjectPath\n) {\n  const resolveInfoName = createResolveInfoName(responsePath);\n  const { schema, fragments, operation } = context;\n\n  context.resolveInfos[resolveInfoName] = createResolveInfoThunk(\n    {\n      schema,\n      fragments,\n      operation,\n      parentType,\n      fieldName,\n      fieldType,\n      fieldNodes\n    },\n    context.options.resolverInfoEnricher\n  );\n  return `${GLOBAL_EXECUTION_CONTEXT}.resolveInfos.${resolveInfoName}(${GLOBAL_ROOT_NAME}, ${GLOBAL_VARIABLES_NAME}, ${serializeResponsePath(\n    responsePath\n  )})`;\n}\n\nfunction getArgumentsName(prefixName: string) {\n  return `${prefixName}Args`;\n}\n\nfunction getValidArgumentsVarName(prefixName: string) {\n  return `${prefixName}ValidArgs`;\n}\n\nfunction objectPath(topLevel: string, path?: ObjectPath) {\n  if (!path) {\n    return topLevel;\n  }\n  let objectPath = topLevel;\n  const flattened = flattenPath(path);\n  for (const section of flattened) {\n    if (section.type === \"literal\") {\n      objectPath += `[\"${section.key}\"]`;\n    } else {\n      /* istanbul ignore next */\n      throw new Error(\"should only have received literal paths\");\n    }\n  }\n  return objectPath;\n}\n\n/**\n * Returns a static object with the all the arguments needed for the resolver\n * @param context\n * @param {Arguments} args\n * @param topLevelArg name of the toplevel\n * @param validArgs\n * @param returnType\n * @param path\n * @returns {string}\n */\nfunction compileArguments(\n  context: CompilationContext,\n  args: Arguments,\n  topLevelArg: string,\n  validArgs: string,\n  returnType: GraphQLOutputType,\n  path: ObjectPath\n): string {\n  // default to assuming arguments are valid\n  let body = `\n  let ${validArgs} = true;\n  const ${topLevelArg} = ${objectStringify(args.values)};\n  `;\n  const errorDestination = getErrorDestination(returnType);\n  for (const variable of args.missing) {\n    const varName = variable.valueNode.name.value;\n    body += `if (Object.prototype.hasOwnProperty.call(${GLOBAL_VARIABLES_NAME}, \"${varName}\")) {`;\n    if (variable.argument && isNonNullType(variable.argument.definition.type)) {\n      const message = `'Argument \"${\n        variable.argument.definition.name\n      }\" of non-null type \"${variable.argument.definition.type.toString()}\" must not be null.'`;\n      body += `if (${GLOBAL_VARIABLES_NAME}['${\n        variable.valueNode.name.value\n      }'] == null) {\n      ${errorDestination}.push(${createErrorObject(\n        context,\n        [variable.argument.node.value],\n        path,\n        message\n      )});\n      ${validArgs} = false;\n      }`;\n    }\n    body += `\n    ${objectPath(topLevelArg, variable.path)} = ${GLOBAL_VARIABLES_NAME}['${\n      variable.valueNode.name.value\n    }'];\n    }`;\n    // If there is no default value and no variable input\n    // throw a field error\n    if (\n      variable.argument &&\n      isNonNullType(variable.argument.definition.type) &&\n      variable.argument.definition.defaultValue === undefined\n    ) {\n      const message = `'Argument \"${\n        variable.argument.definition.name\n      }\" of required type \"${variable.argument.definition.type.toString()}\" was provided the variable \"$${varName}\" which was not provided a runtime value.'`;\n      body += ` else {\n      ${errorDestination}.push(${createErrorObject(\n        context,\n        [variable.argument.node.value],\n        path,\n        message\n      )});\n      ${validArgs} = false;\n        }`;\n    }\n  }\n  return body;\n}\n\n/**\n *  Safety checks for resolver execution is done via side effects every time a resolver function\n *  is encountered.\n *\n *  This function generates the declarations, so the side effect is valid code.\n *\n * @param {CompilationContext} context compilation context\n * @param {boolean} defaultValue usually false, meant to be true at the top level\n * @returns {string} a list of declarations eg: var __validNode0 = false;\\nvar __validNode1 = false;\n */\nfunction generateUniqueDeclarations(\n  context: CompilationContext,\n  defaultValue = false\n) {\n  return context.deferred\n    .map(\n      (_, idx) => `\n        let ${SAFETY_CHECK_PREFIX}${idx} = ${defaultValue};\n      `\n    )\n    .join(\"\\n\");\n}\n\nfunction createSubCompilationContext(\n  context: CompilationContext\n): CompilationContext {\n  return { ...context, deferred: [] };\n}\n\nexport function isPromise(value: any): value is Promise<any> {\n  return (\n    value != null &&\n    typeof value === \"object\" &&\n    typeof value.then === \"function\"\n  );\n}\n\nexport function isPromiseInliner(value: string): string {\n  return `${value} != null && typeof ${value} === \"object\" && typeof ${value}.then === \"function\"`;\n}\n\n/**\n * Serializes the response path for an error response.\n *\n * @param {ObjectPath | undefined} path response path of a field\n * @returns {string} filtered serialization of the response path\n */\nfunction serializeResponsePathAsArray(path: ObjectPath) {\n  const flattened = flattenPath(path);\n  let src = \"[\";\n  for (let i = flattened.length - 1; i >= 0; i--) {\n    // meta is only used for the function name\n    if (flattened[i].type === \"meta\") {\n      continue;\n    }\n    src +=\n      flattened[i].type === \"literal\"\n        ? `\"${flattened[i].key}\",`\n        : `${flattened[i].key},`;\n  }\n  return src + \"]\";\n}\n\nfunction getErrorDestination(type: GraphQLType): string {\n  return isNonNullType(type) ? GLOBAL_NULL_ERRORS_NAME : GLOBAL_ERRORS_NAME;\n}\n\nfunction createResolveInfoName(path: ObjectPath) {\n  return (\n    flattenPath(path)\n      .map((p) => p.key)\n      .join(\"_\") + \"Info\"\n  );\n}\n\n/**\n * Serializes the response path for the resolve info function\n * @param {ObjectPath | undefined} path response path of a field\n * @returns {string} filtered serialization of the response path\n */\nfunction serializeResponsePath(path: ObjectPath | undefined): string {\n  if (!path) {\n    return \"undefined\";\n  }\n  if (path.type === \"meta\") {\n    // meta is ignored while serializing for the resolve info functions\n    return serializeResponsePath(path.prev);\n  }\n  const literalValue = `\"${path.key}\"`;\n  return `{\n    key:  ${path.type === \"literal\" ? literalValue : path.key},\n    prev: ${serializeResponsePath(path.prev)}\n  }`;\n}\n\n/**\n * Returned a bound serialization function of a scalar or enum\n * @param {GraphQLScalarType | GraphQLEnumType} scalar\n * @param customSerializer custom serializer\n * @returns {(v: any) => any} bound serializationFunction\n */\nfunction getSerializer(\n  scalar: GraphQLScalarType | GraphQLEnumType,\n  customSerializer?: GraphQLScalarSerializer<any>\n) {\n  const { name } = scalar;\n  const serialize = customSerializer || ((val: any) => scalar.serialize(val));\n  return function leafSerializer(\n    context: ExecutionContext,\n    v: any,\n    onError: (c: ExecutionContext, msg: string, ...idx: number[]) => void,\n    ...idx: number[]\n  ) {\n    try {\n      const value = serialize(v);\n      if (isInvalid(value)) {\n        onError(\n          context,\n          `Expected a value of type \"${name}\" but received: ${v}`,\n          ...idx\n        );\n        return null;\n      }\n      return value;\n    } catch (e: any) {\n      onError(\n        context,\n        (e && e.message) ||\n          `Expected a value of type \"${name}\" but received an Error`,\n        ...idx\n      );\n      return null;\n    }\n  };\n}\n\n/**\n * Default abstract type resolver.\n *\n * It only handle sync type resolving.\n * @param value\n * @param contextValue\n * @param {GraphQLResolveInfo} info\n * @param {GraphQLAbstractType} abstractType\n * @returns {string}\n */\nfunction defaultResolveTypeFn(\n  value: any,\n  contextValue: any,\n  info: GraphQLResolveInfo,\n  abstractType: GraphQLAbstractType\n): string {\n  // First, look for `__typename`.\n  if (\n    value != null &&\n    typeof value === \"object\" &&\n    typeof value.__typename === \"string\"\n  ) {\n    return value.__typename;\n  }\n\n  // Otherwise, test each possible type.\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  for (const type of possibleTypes) {\n    if (type.isTypeOf) {\n      const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n      if (isPromise(isTypeOfResult)) {\n        throw new Error(\n          `Promises are not supported for resolving type of ${value}`\n        );\n      } else if (isTypeOfResult) {\n        return type.name;\n      }\n    }\n  }\n\n  throw new Error(\n    `Could not resolve the object type in possible types of ${abstractType.name} for the value: ` +\n      inspect(value)\n  );\n}\n\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n */\nfunction buildCompilationContext(\n  schema: GraphQLSchema,\n  document: DocumentNode,\n  options: CompilerOptions,\n  operationName?: string\n): CompilationContext {\n  const errors: GraphQLError[] = [];\n  let operation: OperationDefinitionNode | undefined = undefined;\n  let hasMultipleAssumedOperations = false;\n  const fragments: { [key: string]: FragmentDefinitionNode } =\n    Object.create(null);\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (!operationName && operation) {\n          hasMultipleAssumedOperations = true;\n        } else if (\n          !operationName ||\n          (definition.name && definition.name.value === operationName)\n        ) {\n          operation = definition;\n        }\n        break;\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n    }\n  }\n\n  if (!operation) {\n    if (operationName) {\n      throw new GraphQLError(`Unknown operation named \"${operationName}\".`);\n    } else {\n      throw new GraphQLError(\"Must provide an operation.\");\n    }\n  } else if (hasMultipleAssumedOperations) {\n    throw new GraphQLError(\n      \"Must provide operation name if query contains multiple operations.\"\n    );\n  }\n\n  return {\n    schema,\n    fragments,\n    rootValue: null,\n    contextValue: null,\n    operation,\n    options,\n    resolvers: {},\n    serializers: {},\n    typeResolvers: {},\n    isTypeOfs: {},\n    resolveInfos: {},\n    hoistedFunctions: [],\n    hoistedFunctionNames: new Map(),\n    deferred: [],\n    depth: -1,\n    variableValues: {},\n    errors\n  } as unknown as CompilationContext;\n}\n\nfunction getFieldNodesName(nodes: FieldNode[]) {\n  return nodes.length > 1\n    ? \"(\" + nodes.map(({ name }) => name.value).join(\",\") + \")\"\n    : nodes[0].name.value;\n}\n\nfunction getHoistedFunctionName(context: CompilationContext, name: string) {\n  const count = context.hoistedFunctionNames.get(name);\n  if (count === undefined) {\n    context.hoistedFunctionNames.set(name, 0);\n    return name;\n  }\n  context.hoistedFunctionNames.set(name, count + 1);\n  return `${name}${count + 1}`;\n}\n\nfunction createErrorObject(\n  context: CompilationContext,\n  nodes: ASTNode[],\n  path: ObjectPath,\n  message: string,\n  originalError?: string\n): string {\n  return `new ${GRAPHQL_ERROR}(${message},\n    ${JSON.stringify(computeLocations(nodes))},\n      ${serializeResponsePathAsArray(path)},\n      ${originalError || \"undefined\"},\n      ${context.options.disablingCapturingStackErrors ? \"true\" : \"false\"})`;\n}\n\nfunction getResolverName(parentName: string, name: string) {\n  return parentName + name + \"Resolver\";\n}\n\nfunction getTypeResolverName(name: string) {\n  return name + \"TypeResolver\";\n}\n\nfunction getSerializerName(name: string) {\n  return name + \"Serializer\";\n}\n\nfunction promiseStarted() {\n  return `\n     // increase the promise counter\n     ++${GLOBAL_PROMISE_COUNTER};\n  `;\n}\n\nfunction promiseDone() {\n  return `\n    --${GLOBAL_PROMISE_COUNTER};\n    if (${GLOBAL_PROMISE_COUNTER} === 0) {\n      ${GLOBAL_RESOLVE}(${GLOBAL_EXECUTION_CONTEXT});\n    }\n  `;\n}\n\nfunction normalizeErrors(err: Error[] | Error): GraphQLError[] {\n  if (Array.isArray(err)) {\n    return err.map((e) => normalizeError(e));\n  }\n  return [normalizeError(err)];\n}\n\nfunction normalizeError(err: Error): GraphQLError {\n  return err instanceof GraphQLError\n    ? err\n    : new (GraphqlJitError as any)(\n        err.message,\n        (err as any).locations,\n        (err as any).path,\n        err\n      );\n}\n\n/**\n * Returns true if a value is undefined, or NaN.\n */\nfunction isInvalid(value: any): boolean {\n  // eslint-disable-next-line no-self-compare\n  return value === undefined || value !== value;\n}\n\nfunction getParentArgIndexes(context: CompilationContext) {\n  let args = \"\";\n  for (let i = 0; i <= context.depth; ++i) {\n    if (i > 0) {\n      args += \", \";\n    }\n    args += `idx${i}`;\n  }\n  return args;\n}\n\nfunction getJsFieldName(fieldName: string) {\n  return `${LOCAL_JS_FIELD_NAME_PREFIX}${fieldName}`;\n}\n\nexport function isAsyncIterable<T = unknown>(\n  val: unknown\n): val is AsyncIterableIterator<T> {\n  return typeof Object(val)[Symbol.asyncIterator] === \"function\";\n}\n\nfunction compileSubscriptionOperation(\n  context: CompilationContext,\n  type: GraphQLObjectType,\n  fieldMap: FieldsAndNodes,\n  queryFn: CompiledQuery[\"query\"]\n) {\n  const fieldNodes = Object.values(fieldMap)[0];\n  const fieldNode = fieldNodes[0];\n  const fieldName = fieldNode.name.value;\n\n  const field = resolveFieldDef(context, type, fieldNodes);\n\n  if (!field) {\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      getGraphQLErrorOptions(fieldNodes)\n    );\n  }\n\n  const responsePath = addPath(undefined, fieldName);\n  const resolveInfoName = createResolveInfoName(responsePath);\n\n  const subscriber = field.subscribe;\n\n  async function executeSubscription(executionContext: ExecutionContext) {\n    const resolveInfo = executionContext.resolveInfos[resolveInfoName](\n      executionContext.rootValue,\n      executionContext.variables,\n      responsePath\n    );\n\n    try {\n      const eventStream = await subscriber?.(\n        executionContext.rootValue,\n        executionContext.variables,\n        executionContext.context,\n        resolveInfo\n      );\n      if (eventStream instanceof Error) {\n        throw eventStream;\n      }\n      return eventStream;\n    } catch (error) {\n      throw locatedError(\n        error,\n        resolveInfo.fieldNodes,\n        pathToArray(resolveInfo.path)\n      );\n    }\n  }\n\n  async function createSourceEventStream(executionContext: ExecutionContext) {\n    try {\n      const eventStream = await executeSubscription(executionContext);\n\n      // Assert field returned an event stream, otherwise yield an error.\n      if (!isAsyncIterable(eventStream)) {\n        throw new Error(\n          \"Subscription field must return Async Iterable. \" +\n            `Received: ${inspect(eventStream)}.`\n        );\n      }\n\n      return eventStream;\n    } catch (error) {\n      // If it is a GraphQLError, report it as an ExecutionResult, containing only errors and no data.\n      // Otherwise treat the error as a system-class error and re-throw it.\n      if (error instanceof GraphQLError) {\n        return { errors: [error] };\n      }\n      throw error;\n    }\n  }\n\n  return async function subscribe(executionContext: ExecutionContext) {\n    const resultOrStream = await createSourceEventStream(executionContext);\n\n    if (!isAsyncIterable(resultOrStream)) {\n      return resultOrStream;\n    }\n\n    // For each payload yielded from a subscription, map it over the normal\n    // GraphQL `execute` function, with `payload` as the rootValue.\n    // This implements the \"MapSourceToResponseEvent\" algorithm described in\n    // the GraphQL specification. The `execute` function provides the\n    // \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n    // \"ExecuteQuery\" algorithm, for which `execute` is also used.\n    // We use our `query` function in place of `execute`\n    const mapSourceToResponse = (payload: any) =>\n      queryFn(payload, executionContext.context, executionContext.variables);\n\n    return mapAsyncIterator(resultOrStream, mapSourceToResponse);\n  };\n}\n\nfunction createBoundSubscribe(\n  compilationContext: CompilationContext,\n  document: DocumentNode,\n  func: (\n    context: ExecutionContext\n  ) => Promise<AsyncIterableIterator<ExecutionResult> | ExecutionResult>,\n  getVariableValues: (inputs: { [key: string]: any }) => CoercedVariableValues,\n  operationName: string | undefined\n): CompiledQuery[\"subscribe\"] {\n  const { resolvers, typeResolvers, isTypeOfs, serializers, resolveInfos } =\n    compilationContext;\n  const trimmer = createNullTrimmer(compilationContext);\n  const fnName = operationName || \"subscribe\";\n\n  const ret = {\n    async [fnName](\n      rootValue: any,\n      context: any,\n      variables: Maybe<{ [key: string]: any }>\n    ): Promise<AsyncIterableIterator<ExecutionResult> | ExecutionResult> {\n      // this can be shared across in a batch request\n      const parsedVariables = getVariableValues(variables || {});\n\n      // Return early errors if variable coercing failed.\n      if (failToParseVariables(parsedVariables)) {\n        return { errors: parsedVariables.errors };\n      }\n\n      const executionContext: ExecutionContext = {\n        rootValue,\n        context,\n        variables: parsedVariables.coerced,\n        safeMap,\n        inspect,\n        GraphQLError: GraphqlJitError,\n        resolvers,\n        typeResolvers,\n        isTypeOfs,\n        serializers,\n        resolveInfos,\n        trimmer,\n        promiseCounter: 0,\n        nullErrors: [],\n        errors: [],\n        data: {}\n      };\n\n      // eslint-disable-next-line no-useless-call\n      return func.call(null, executionContext);\n    }\n  };\n\n  return ret[fnName];\n}\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator<T, U, R = undefined>(\n  iterable: AsyncGenerator<T, R, undefined> | AsyncIterable<T>,\n  callback: (value: T) => U | Promise<U>\n): AsyncGenerator<U, R, undefined> {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(\n    result: IteratorResult<T, R>\n  ): Promise<IteratorResult<U, R>> {\n    if (result.done) {\n      return result;\n    }\n\n    try {\n      return { value: await callback(result.value), done: false };\n    } catch (error) {\n      if (typeof iterator.return === \"function\") {\n        try {\n          await iterator.return();\n        } catch (e) {\n          /* ignore error */\n        }\n      }\n      throw error;\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(await iterator.next());\n    },\n    async return(): Promise<IteratorResult<U, R>> {\n      return typeof iterator.return === \"function\"\n        ? mapResult(await iterator.return())\n        : { value: undefined as unknown as R, done: true };\n    },\n    async throw(error?: Error) {\n      return typeof iterator.throw === \"function\"\n        ? mapResult(await iterator.throw(error))\n        : Promise.reject(error);\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}\n\nfunction joinOriginPathsImpl(originPaths: string[]) {\n  return originPaths.join(\".\");\n}\n\nfunction isNotNull<T>(it: T): it is Exclude<T, null | undefined> {\n  return it != null;\n}\n"],"mappings":"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","names":["fieldNodes","context","objectPath"]}