{"version":3,"sources":["../src/variables.ts"],"sourcesContent":["import { genFn } from \"./generate\";\nimport {\n  GraphQLBoolean,\n  GraphQLError,\n  GraphQLFloat,\n  GraphQLID,\n  type GraphQLInputType,\n  GraphQLInt,\n  GraphQLSchema,\n  GraphQLString,\n  isEnumType,\n  isInputType,\n  isListType,\n  isNonNullType,\n  isScalarType,\n  print,\n  type SourceLocation,\n  typeFromAST,\n  valueFromAST,\n  type VariableDefinitionNode\n} from \"graphql\";\nimport { addPath, computeLocations, type ObjectPath } from \"./ast.js\";\nimport { GraphQLError as GraphQLJITError } from \"./error.js\";\nimport createInspect from \"./inspect.js\";\n\nconst inspect = createInspect();\n\ninterface FailedVariableCoercion {\n  errors: ReadonlyArray<GraphQLError>;\n}\n\ninterface VariableValues {\n  coerced: { [key: string]: any };\n}\n\nexport type CoercedVariableValues = FailedVariableCoercion | VariableValues;\n\nexport function failToParseVariables(x: any): x is FailedVariableCoercion {\n  return x.errors;\n}\n\ninterface CompilationContext {\n  inputPath: ObjectPath;\n  responsePath: ObjectPath;\n  depth: number;\n  varDefNode: VariableDefinitionNode;\n  dependencies: Map<string, (...args: any[]) => any>;\n  errorMessage?: string;\n}\n\nfunction createSubCompilationContext(\n  context: CompilationContext\n): CompilationContext {\n  return { ...context };\n}\nexport function compileVariableParsing(\n  schema: GraphQLSchema,\n  varDefNodes: ReadonlyArray<VariableDefinitionNode>\n): (inputs: { [key: string]: any }) => CoercedVariableValues {\n  const errors = [];\n  const coercedValues: { [key: string]: any } = Object.create(null);\n\n  let mainBody = \"\";\n  const dependencies = new Map();\n  for (const varDefNode of varDefNodes) {\n    const context: CompilationContext = {\n      varDefNode,\n      depth: 0,\n      inputPath: addPath(undefined, \"input\"),\n      responsePath: addPath(undefined, \"coerced\"),\n      dependencies\n    };\n    const varName = varDefNode.variable.name.value;\n    const varType = typeFromAST(schema, varDefNode.type as any);\n    if (!varType || !isInputType(varType)) {\n      // Must use input types for variables. This should be caught during\n      // validation, however is checked again here for safety.\n      errors.push(\n        new (GraphQLJITError as any)(\n          `Variable \"$${varName}\" expected value of type ` +\n            `\"${\n              varType || print(varDefNode.type)\n            }\" which cannot be used as an input type.`,\n          computeLocations([varDefNode.type])\n        )\n      );\n      continue;\n    }\n\n    // Ensure a constant shape of the input map\n    coercedValues[varName] = undefined;\n    const hasValueName = hasValue(addPath(context.inputPath, varName));\n    mainBody += `const ${hasValueName} = Object.prototype.hasOwnProperty.call(${getObjectPath(\n      context.inputPath\n    )}, \"${varName}\");\\n`;\n    context.inputPath = addPath(context.inputPath, varName);\n    context.responsePath = addPath(context.responsePath, varName);\n    mainBody += generateInput(\n      context,\n      varType,\n      varName,\n      hasValueName,\n      valueFromAST(varDefNode.defaultValue, varType),\n      false\n    );\n  }\n\n  if (errors.length > 0) {\n    throw errors;\n  }\n\n  const gen = genFn();\n  gen(`\n    return function getVariables(input) {\n      const errors = [];\n      const coerced = ${JSON.stringify(coercedValues)}\n      ${mainBody}\n      if (errors.length > 0) {\n        return {errors, coerced: undefined};\n      }\n      return {errors: undefined, coerced};\n    }\n  `);\n\n  // eslint-disable-next-line\n  return Function.apply(\n    null,\n    [\"GraphQLJITError\", \"inspect\"]\n      .concat(Array.from(dependencies.keys()))\n      .concat(gen.toString())\n  ).apply(\n    null,\n    [GraphQLJITError, inspect].concat(Array.from(dependencies.values()))\n  );\n}\n\n// Int Scalars represent 32 bits\n// https://graphql.github.io/graphql-spec/June2018/#sec-Int\nconst MAX_32BIT_INT = 2147483647;\nconst MIN_32BIT_INT = -2147483648;\n\nfunction generateInput(\n  context: CompilationContext,\n  varType: GraphQLInputType,\n  varName: string,\n  hasValueName: string,\n  defaultValue: unknown | undefined,\n  wrapInList: boolean\n) {\n  const currentOutput = getObjectPath(context.responsePath);\n  const currentInput = getObjectPath(context.inputPath);\n  const errorLocation = printErrorLocation(\n    computeLocations([context.varDefNode])\n  );\n\n  const gen = genFn();\n  gen(`if (${currentInput} == null) {`);\n\n  if (isNonNullType(varType)) {\n    let nonNullMessage;\n    let omittedMessage;\n    if (context.errorMessage) {\n      const objectPath = printObjectPath(context.responsePath);\n      nonNullMessage = `${context.errorMessage} + \\`Expected non-nullable type ${varType} not to be null at ${objectPath}.\\``;\n      omittedMessage = `${context.errorMessage} + \\`Field ${objectPath} of required type ${varType} was not provided.\\``;\n    } else {\n      nonNullMessage = `'Variable \"$${varName}\" of non-null type \"${varType}\" must not be null.'`;\n      omittedMessage = `'Variable \"$${varName}\" of required type \"${varType}\" was not provided.'`;\n    }\n    varType = varType.ofType;\n    gen(`\n      if (${currentOutput} == null) {\n        errors.push(new GraphQLJITError(${hasValueName} ? ${nonNullMessage} : ${omittedMessage}, ${errorLocation}));\n      }\n    `);\n  } else {\n    gen(`\n      if (${hasValueName}) { ${currentOutput} = null; }\n    `);\n    if (defaultValue !== undefined) {\n      gen(`else { ${currentOutput} = ${JSON.stringify(defaultValue)} }`);\n    }\n  }\n  gen(`} else {`);\n  if (isScalarType(varType)) {\n    switch (varType.name) {\n      case GraphQLID.name:\n        gen(`\n          if (typeof ${currentInput} === \"string\") {\n            ${currentOutput} = ${currentInput};\n          } else if (Number.isInteger(${currentInput})) {\n            ${currentOutput} = ${currentInput}.toString();\n          } else {\n            errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n              inspect(${currentInput}) + \"; \" +\n              'Expected type ${varType.name}; ' +\n              '${varType.name} cannot represent value: ' +\n              inspect(${currentInput}), ${errorLocation})\n            );\n          }\n        `);\n        break;\n      case GraphQLString.name:\n        gen(`\n          if (typeof ${currentInput} === \"string\") {\n              ${currentOutput} = ${currentInput};\n          } else {\n            errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n              inspect(${currentInput}) + \"; \" +\n              'Expected type ${varType.name}; ' +\n              '${varType.name} cannot represent a non string value: ' +\n              inspect(${currentInput}), ${errorLocation})\n            );\n          }\n        `);\n        break;\n      case GraphQLBoolean.name:\n        gen(`\n        if (typeof ${currentInput} === \"boolean\") {\n            ${currentOutput} = ${currentInput};\n        } else {\n          errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n          inspect(${currentInput}) + \"; \" +\n          'Expected type ${varType.name}; ' +\n          '${varType.name} cannot represent a non boolean value: ' +\n          inspect(${currentInput}), ${errorLocation}));\n        }\n        `);\n        break;\n      case GraphQLInt.name:\n        gen(`\n        if (Number.isInteger(${currentInput})) {\n          if (${currentInput} > ${MAX_32BIT_INT} || ${currentInput} < ${MIN_32BIT_INT}) {\n            errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Expected type ${varType.name}; ' +\n            '${varType.name} cannot represent non 32-bit signed integer value: ' +\n            inspect(${currentInput}), ${errorLocation}));\n          } else {\n            ${currentOutput} = ${currentInput};\n          }\n        } else {\n          errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Expected type ${varType.name}; ' +\n            '${varType.name} cannot represent non-integer value: ' +\n            inspect(${currentInput}), ${errorLocation})\n          );\n        }\n        `);\n        break;\n      case GraphQLFloat.name:\n        gen(`\n        if (Number.isFinite(${currentInput})) {\n            ${currentOutput} = ${currentInput};\n        } else {\n          errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Expected type ${varType.name}; ' +\n            '${varType.name} cannot represent non numeric value: ' +\n            inspect(${currentInput}), ${errorLocation})\n          );\n        }\n        `);\n        break;\n      default:\n        context.dependencies.set(\n          `${varType.name}parseValue`,\n          varType.parseValue.bind(varType)\n        );\n        gen(`\n          try {\n            const parseResult = ${varType.name}parseValue(${currentInput});\n            if (parseResult === undefined || parseResult !== parseResult) {\n              errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n              inspect(${currentInput}) + \"; \" +\n              'Expected type ${varType.name}.', ${errorLocation}));\n            }\n            ${currentOutput} = parseResult;\n          } catch (error) {\n            errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n              inspect(${currentInput}) + \"; \" +\n              'Expected type ${varType.name}.', ${errorLocation}, undefined, error)\n            );\n          }\n        `);\n    }\n  } else if (isEnumType(varType)) {\n    context.dependencies.set(\n      `${varType.name}getValue`,\n      varType.getValue.bind(varType)\n    );\n    gen(`\n      if (typeof ${currentInput} === \"string\") {\n        const enumValue = ${varType.name}getValue(${currentInput});\n        if (enumValue) {\n          ${currentOutput} = enumValue.value;\n        } else {\n          errors.push(\n            new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Expected type ${varType.name}.', ${errorLocation})\n          );\n        }\n      } else {\n        errors.push(\n          new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n          inspect(${currentInput}) + \"; \" +\n          'Expected type ${varType.name}.', ${errorLocation})\n        );\n      }\n      `);\n  } else if (isListType(varType)) {\n    context.errorMessage = `'Variable \"$${varName}\" got invalid value ' + inspect(${currentInput}) + '; '`;\n    const hasValueName = hasValue(context.inputPath);\n    const index = `idx${context.depth}`;\n\n    const subContext = createSubCompilationContext(context);\n    subContext.responsePath = addPath(\n      subContext.responsePath,\n      index,\n      \"variable\"\n    );\n    subContext.inputPath = addPath(subContext.inputPath, index, \"variable\");\n    subContext.depth++;\n    gen(`\n      if (Array.isArray(${currentInput})) {\n        ${currentOutput} = [];\n        for (let ${index} = 0; ${index} < ${currentInput}.length; ++${index}) {\n          const ${hasValueName} =\n          ${getObjectPath(subContext.inputPath)} !== undefined;\n          ${generateInput(\n            subContext,\n            varType.ofType,\n            varName,\n            hasValueName,\n            undefined,\n            false\n          )}\n        }\n      } else {\n        ${generateInput(\n          context,\n          varType.ofType,\n          varName,\n          hasValueName,\n          undefined,\n          true\n        )}\n      }\n    `);\n  } else if (isInputType(varType)) {\n    gen(`\n      if (typeof ${currentInput} !== 'object') {\n        errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n        inspect(${currentInput}) + \"; \" +\n        'Expected type ${varType.name} to be an object.', ${errorLocation}));\n      } else {\n        ${currentOutput} = {};\n    `);\n    const fields = varType.getFields();\n    const allowedFields = [];\n    for (const field of Object.values(fields)) {\n      const subContext = createSubCompilationContext(context);\n      allowedFields.push(field.name);\n      const hasValueName = hasValue(addPath(subContext.inputPath, field.name));\n      gen(`\n        const ${hasValueName} = Object.prototype.hasOwnProperty.call(\n          ${getObjectPath(subContext.inputPath)}, \"${field.name}\"\n        );\n      `);\n      subContext.inputPath = addPath(subContext.inputPath, field.name);\n      subContext.responsePath = addPath(subContext.responsePath, field.name);\n      subContext.errorMessage = `'Variable \"$${varName}\" got invalid value ' + inspect(${currentInput}) + '; '`;\n      gen(`\n        ${generateInput(\n          subContext,\n          field.type,\n          field.name,\n          hasValueName,\n          field.defaultValue,\n          false\n        )}\n      `);\n    }\n\n    gen(`\n      const allowedFields = ${JSON.stringify(allowedFields)};\n      for (const fieldName of Object.keys(${currentInput})) {\n        if (!allowedFields.includes(fieldName)) {\n          errors.push(new GraphQLJITError('Variable \"$${varName}\" got invalid value ' +\n            inspect(${currentInput}) + \"; \" +\n            'Field \"' + fieldName + '\" is not defined by type ${\n              varType.name\n            }.', ${errorLocation}));\n          break;\n        }\n      }\n    }`);\n  } else {\n    /* istanbul ignore next line */\n    throw new Error(`unknown type: ${varType}`);\n  }\n  if (wrapInList) {\n    gen(`${currentOutput} = [${currentOutput}];`);\n  }\n  gen(`}`);\n  return gen.toString();\n}\n\nfunction hasValue(path: ObjectPath) {\n  const flattened = [];\n  let curr: ObjectPath | undefined = path;\n  while (curr) {\n    flattened.push(curr.key);\n    curr = curr.prev;\n  }\n  return `hasValue${flattened.join(\"_\")}`;\n}\n\nfunction printErrorLocation(location: SourceLocation[]) {\n  return JSON.stringify(location);\n}\n\nfunction getObjectPath(path: ObjectPath): string {\n  const flattened = [];\n  let curr: ObjectPath | undefined = path;\n  while (curr) {\n    flattened.unshift({ key: curr.key, type: curr.type });\n    curr = curr.prev;\n  }\n  let name = flattened[0].key;\n  for (let i = 1; i < flattened.length; ++i) {\n    name +=\n      flattened[i].type === \"literal\"\n        ? `[\"${flattened[i].key}\"]`\n        : `[${flattened[i].key}]`;\n  }\n  return name;\n}\n\nfunction printObjectPath(path: ObjectPath) {\n  const flattened = [];\n  let curr: ObjectPath | undefined = path;\n  while (curr) {\n    flattened.unshift({ key: curr.key, type: curr.type });\n    curr = curr.prev;\n  }\n  const initialIndex = Math.min(flattened.length - 1, 1);\n  let name = \"value\";\n  for (let i = initialIndex + 1; i < flattened.length; ++i) {\n    name +=\n      flattened[i].type === \"literal\"\n        ? `.${flattened[i].key}`\n        : `[$\\{${flattened[i].key}}]`;\n  }\n  return name;\n}\n"],"mappings":"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","names":["createInspect","GraphQLJITError","hasValueName"]}