import { isEnumType, } from 'graphql';
import { resolvers as scalarResolvers } from 'graphql-scalars';
import lodashGet from 'lodash.get';
import { fs, path, process } from '@graphql-mesh/cross-helpers';
import { stringInterpolator } from '@graphql-mesh/string-interpolation';
import { createDefaultExecutor, ObjMapScalar, } from '@graphql-mesh/transport-common';
import { mapMaybePromise } from '@graphql-mesh/utils';
import { getDirective, getDirectives, getRootTypes } from '@graphql-tools/utils';
import { credentials, loadPackageDefinition } from '@grpc/grpc-js';
import { fromJSON } from '@grpc/proto-loader';
import { DisposableStack } from '@whatwg-node/disposablestack';
import { addExecutionLogicToScalar, addMetaDataToCall } from './utils.js';
import './patchLongJs.js';
export class GrpcTransportHelper extends DisposableStack {
    constructor(baseDir, logger, endpoint, config) {
        super();
        this.baseDir = baseDir;
        this.logger = logger;
        this.endpoint = endpoint;
        this.config = config;
        this.grpcObjectByserviceClientByObjPath = new WeakMap();
    }
    getCredentials() {
        this.logger.debug(`Getting channel credentials`);
        if (this.config.credentialsSsl) {
            this.logger.debug(() => `Using SSL Connection with credentials at ${this.config.credentialsSsl.privateKey} & ${this.config.credentialsSsl.certChain}`);
            const absolutePrivateKeyPath = path.isAbsolute(this.config.credentialsSsl.privateKey)
                ? this.config.credentialsSsl.privateKey
                : path.join(this.baseDir, this.config.credentialsSsl.privateKey);
            const absoluteCertChainPath = path.isAbsolute(this.config.credentialsSsl.certChain)
                ? this.config.credentialsSsl.certChain
                : path.join(this.baseDir, this.config.credentialsSsl.certChain);
            const sslFiles = [
                fs.promises.readFile(absolutePrivateKeyPath),
                fs.promises.readFile(absoluteCertChainPath),
            ];
            if (this.config.credentialsSsl.rootCA !== 'rootCA') {
                const absoluteRootCAPath = path.isAbsolute(this.config.credentialsSsl.rootCA)
                    ? this.config.credentialsSsl.rootCA
                    : path.join(this.baseDir, this.config.credentialsSsl.rootCA);
                sslFiles.unshift(fs.promises.readFile(absoluteRootCAPath));
            }
            return Promise.all(sslFiles).then(([rootCA, privateKey, certChain]) => credentials.createSsl(rootCA, privateKey, certChain));
        }
        else if (this.config.useHTTPS) {
            this.logger.debug(`Using SSL Connection`);
            return credentials.createSsl();
        }
        this.logger.debug(`Using insecure connection`);
        return credentials.createInsecure();
    }
    getGrpcObject({ rootJson, loadOptions, rootLogger, }) {
        const packageDefinition = fromJSON(rootJson, loadOptions);
        rootLogger.debug(`Creating service client for package definition`);
        const grpcObject = loadPackageDefinition(packageDefinition);
        return grpcObject;
    }
    getServiceClient({ grpcObject, objPath, creds, }) {
        let serviceClientByObjPath = this.grpcObjectByserviceClientByObjPath.get(grpcObject);
        if (!serviceClientByObjPath) {
            serviceClientByObjPath = new Map();
            this.grpcObjectByserviceClientByObjPath.set(grpcObject, serviceClientByObjPath);
        }
        let client = serviceClientByObjPath.get(objPath);
        if (!client) {
            const ServiceClient = lodashGet(grpcObject, objPath);
            if (typeof ServiceClient !== 'function') {
                throw new Error(`Object at path ${objPath} is not a Service constructor`);
            }
            client = new ServiceClient(stringInterpolator.parse(this.endpoint, { env: process.env }) ?? this.endpoint, creds);
            this.defer(() => client.close());
            serviceClientByObjPath.set(objPath, client);
        }
        return client;
    }
    getFieldResolver({ client, methodName, isResponseStream, }) {
        const metaData = this.config.metaData;
        const clientMethod = client[methodName].bind(client);
        return function grpcFieldResolver(root, args, context) {
            return addMetaDataToCall(clientMethod, args.input, {
                root,
                args,
                context,
                env: process.env,
            }, metaData, isResponseStream);
        };
    }
    getConnectivityStateResolver({ client, }) {
        return function connectivityStateResolver(_, { tryToConnect }) {
            return client.getChannel().getConnectivityState(tryToConnect);
        };
    }
    processDirectives({ schema, creds }) {
        const schemaTypeMap = schema.getTypeMap();
        for (const scalarTypeName in scalarResolvers) {
            if (scalarTypeName in schemaTypeMap) {
                addExecutionLogicToScalar(schemaTypeMap[scalarTypeName], scalarResolvers[scalarTypeName]);
            }
        }
        if ('ObjMap' in schemaTypeMap) {
            addExecutionLogicToScalar(schemaTypeMap.ObjMap, ObjMapScalar);
        }
        const queryType = schema.getQueryType();
        const rootJsonAnnotations = getDirective(schema, queryType, 'grpcRootJson');
        const rootJsonMap = new Map();
        const grpcObjectByRootJsonName = new Map();
        for (let { name, rootJson, loadOptions } of rootJsonAnnotations) {
            rootJson = typeof rootJson === 'string' ? JSON.parse(rootJson) : rootJson;
            rootJsonMap.set(name, rootJson);
            const rootLogger = this.logger.child(name);
            grpcObjectByRootJsonName.set(name, this.getGrpcObject({ rootJson, loadOptions, rootLogger }));
        }
        const rootTypes = getRootTypes(schema);
        for (const rootType of rootTypes) {
            const rootTypeFields = rootType.getFields();
            for (const fieldName in rootTypeFields) {
                const field = rootTypeFields[fieldName];
                const directives = getDirectives(schema, field);
                if (directives?.length) {
                    for (const directiveObj of directives) {
                        switch (directiveObj.name) {
                            case 'grpcMethod': {
                                const { rootJsonName, objPath, methodName, responseStream } = directiveObj.args;
                                const grpcObject = grpcObjectByRootJsonName.get(rootJsonName);
                                const client = this.getServiceClient({
                                    grpcObject,
                                    objPath,
                                    creds,
                                });
                                if (rootType.name === 'Subscription') {
                                    field.subscribe = this.getFieldResolver({
                                        client,
                                        methodName,
                                        isResponseStream: responseStream,
                                    });
                                    field.resolve = function identityFn(root) {
                                        return root;
                                    };
                                }
                                else {
                                    field.resolve = this.getFieldResolver({
                                        client,
                                        methodName,
                                        isResponseStream: responseStream,
                                    });
                                }
                                break;
                            }
                            case 'grpcConnectivityState': {
                                const { rootJsonName, objPath } = directiveObj.args;
                                const grpcObject = grpcObjectByRootJsonName.get(rootJsonName);
                                const client = this.getServiceClient({
                                    grpcObject,
                                    objPath,
                                    creds,
                                });
                                field.resolve = this.getConnectivityStateResolver({ client });
                                break;
                            }
                        }
                    }
                }
            }
        }
        const typeMap = schema.getTypeMap();
        for (const typeName in typeMap) {
            const type = typeMap[typeName];
            if (isEnumType(type)) {
                const values = type.getValues();
                for (const value of values) {
                    const enumAnnotations = getDirective(schema, value, 'enum');
                    if (enumAnnotations?.length) {
                        for (const enumAnnotation of enumAnnotations) {
                            const enumSerializedValue = enumAnnotation.value;
                            if (enumSerializedValue) {
                                const serializedValue = JSON.parse(enumSerializedValue);
                                value.value = serializedValue;
                                let valueLookup = type._valueLookup;
                                if (!valueLookup) {
                                    valueLookup = new Map(type.getValues().map(enumValue => [enumValue.value, enumValue]));
                                    type._valueLookup = valueLookup;
                                }
                                type._valueLookup.set(serializedValue, value);
                            }
                        }
                    }
                }
            }
        }
    }
}
export default {
    getSubgraphExecutor({ transportEntry, subgraph, cwd, logger }) {
        const transport = new GrpcTransportHelper(cwd, logger, transportEntry.location, transportEntry.options);
        return mapMaybePromise(transport.getCredentials(), creds => {
            transport.processDirectives({ schema: subgraph, creds });
            return createDefaultExecutor(subgraph);
        });
    },
};
