import { buildSchema } from 'graphql';
import { PredefinedProxyOptions } from '@graphql-mesh/store';
import { GrpcTransportHelper } from '@graphql-mesh/transport-grpc';
import { readFileOrUrl } from '@graphql-mesh/utils';
import { loadGrpcSubgraph } from '@omnigraph/grpc';
export default class GrpcHandler {
    constructor({ config, baseDir, store, logger, pubsub, importFn, }) {
        this.logger = logger;
        this.config = config;
        this.baseDir = baseDir;
        this.schemaWithAnnotationsProxy = store.proxy('schemaWithAnnotations', PredefinedProxyOptions.GraphQLSchemaWithDiffing);
        this.pubsub = pubsub;
        this.importFn = importFn;
    }
    getCachedNonExecutableSchema() {
        const interpolatedSource = this.config.source?.toString();
        if (interpolatedSource?.endsWith('.graphql')) {
            this.logger.info(`Fetching GraphQL Schema with annotations`);
            return readFileOrUrl(interpolatedSource, {
                allowUnknownExtensions: true,
                cwd: this.baseDir,
                fetch: this.fetchFn,
                importFn: this.importFn,
                logger: this.logger,
                headers: this.config.schemaHeaders,
            }).then(sdl => buildSchema(sdl, { assumeValidSDL: true, assumeValid: true }));
        }
        return this.schemaWithAnnotationsProxy.getWithSet(() => loadGrpcSubgraph('grpc', this.config)({ cwd: this.baseDir, logger: this.logger }).schema$);
    }
    getMeshSource() {
        const transport = new GrpcTransportHelper(this.baseDir, this.logger, this.config.endpoint, this.config);
        const subId = this.pubsub.subscribe('destroy', () => {
            transport.dispose();
            this.pubsub.unsubscribe(subId);
        });
        return Promise.all([transport.getCredentials(), this.getCachedNonExecutableSchema()]).then(([creds, schema]) => {
            transport.processDirectives({ schema, creds });
            return {
                schema,
            };
        });
    }
}
